#lang racket
(require
 srfi/19
 (planet dvanhorn/packrat)
 (planet bzlib/date/srfi)
 (planet bzlib/date-tz)
 "timezone.rkt")

(require test-engine/racket-tests)

; Parsing of times and dates
; Modelled off the 'at' source code

; This parser uses a lexer to reduce the amount of productions. As a
; result, it does not skip any characters and terminates as soon as
; a production is found.

; To skip any leading characters, use (parse-time). In the future, the
; parser and lexer may be united into a combinator for use in other
; parsers.

(define (chars->num . chars)
  (string->number (list->string chars)))

(define (current . tags)
  (let ((now (current-date)))
    (map (lambda (tag)
           (cond ((symbol=? tag 'day) (cons tag (date-day now)))
                 ((symbol=? tag 'month) (cons tag (date-month now)))
                 ((symbol=? tag 'year) (cons tag (date-year now)))
                 ((symbol=? tag 'hour) (cons tag (date-hour now)))
                 ((symbol=? tag 'minute) (cons tag (date-minute now)))
                 ((symbol=? tag 'day-of-week) (cons tag (date-week-day now)))
                 (else (error (format "unknown tag: ~a" tag)))))
         tags)))

(define (day->date day)
  (let* ((now (current-date))
         (year (date-year now))
         (month (date-month now))
         (date (date-day now))
         (next (week-day>mday year month day date)))
    (list (cons 'year (date-year next))
          (cons 'month (date-month next))
          (cons 'day (date-day next)))))

; Checks if a tagged date is in the past and returns the
; date next year if so.
(define (maybe-next-year date)
  (define (val tag def)
    (let ((v (assoc tag date)))
      (if v (cdr v) def)))
  (let* ((today (current-date))
         (year (val 'year (date-year today)))
         (month (val 'month (date-month today)))
         (day (val 'day (date-day today))))
    (list (cons 'year (if (or (< month (date-month today))
                              (and (= month (date-month today))
                                   (< day (date-day today))))
                          (+ 1 year)
                          year))
          (cons 'month month)
          (cons 'day day))))

(define lexer
  (parse <lexeme>
         (<lexeme>
          ((s := <string>) s)
          ((d := <date>) d)
          ((t := <hour-minute>) t)
          ((i := <integer>) i)
          ((z := <timezone>) (cons 'tz z))
          ((w := (? char-whitespace?) l := <lexeme>) l))
         (<string>
          (('#\a '#\m) '(am))
          (('#\p '#\m) '(pm))
          (('#\n '#\o '#\o '#\n) '(noon))
          (('#\m '#\i '#\d '#\d '#\a '#\y) '(midday))
          (('#\m '#\i '#\d '#\n '#\i '#\g '#\h '#\t) '(midnight))
          (('#\s '#\u '#\n '#\d '#\a '#\y) '(sun))
          (('#\s '#\u '#\n) '(sun))
          (('#\m '#\o '#\n '#\d '#\a '#\y) '(mon))
          (('#\m '#\o '#\n) '(mon))
          (('#\t '#\u '#\e '#\s '#\d '#\a '#\y) '(tue))
          (('#\t '#\u '#\e) '(tue))
          (('#\w '#\e '#\d '#\n '#\e '#\s '#\d '#\a '#\y) '(wed))
          (('#\w '#\e '#\d) '(wed))
          (('#\t '#\h '#\u '#\r '#\s '#\d '#\a '#\y) '(thu))
          (('#\t '#\h '#\u) '(thu))
          (('#\f '#\r '#\i '#\d '#\a '#\y) '(fri))
          (('#\f '#\r '#\i) '(fri))
          (('#\s '#\a '#\t '#\u '#\r '#\d '#\a '#\y) '(sat))
          (('#\s '#\a '#\t) '(sat))
          (('#\t '#\o '#\d '#\a '#\y) '(today))
          (('#\t '#\o '#\m '#\o '#\r '#\r '#\o '#\w) '(tomorrow))
          (('#\n '#\e '#\x '#\t) '(next))
          (('#\t '#\h '#\i '#\s) '(this))
          (('#\m '#\i '#\n '#\u '#\t '#\e '#\s) '(minute))
          (('#\m '#\i '#\n '#\u '#\t '#\e) '(minute))
          (('#\m '#\i '#\n) '(minute))
          (('#\h '#\o '#\u '#\r '#\s) '(hour))
          (('#\h '#\o '#\u '#\r) '(hour))
          (('#\d '#\a '#\y '#\s) '(day))
          (('#\d '#\a '#\y) '(day))
          (('#\w '#\e '#\e '#\k '#\s) '(week))
          (('#\w '#\e '#\e '#\k) '(week))
          (('#\m '#\o '#\n '#\t '#\h '#\s) '(month))
          (('#\m '#\o '#\n '#\t '#\h) '(month))
          (('#\y '#\e '#\a '#\r '#\s) '(year))
          (('#\y '#\e '#\a '#\r) '(year))
          (('#\j '#\a '#\n '#\u '#\a '#\r '#\y) '(jan))
          (('#\j '#\a '#\n) '(jan))
          (('#\f '#\e '#\b '#\r '#\u '#\a '#\r '#\y) '(feb))
          (('#\f '#\e '#\b) '(feb))
          (('#\m '#\a '#\r '#\c '#\h) '(mar))
          (('#\m '#\a '#\r) '(mar))
          (('#\a '#\p '#\r '#\i '#\l) '(apr))
          (('#\a '#\p '#\r) '(apr))
          (('#\m '#\a '#\y) '(may))
          (('#\j '#\u '#\n '#\e) '(jun))
          (('#\j '#\u '#\n) '(jun))
          (('#\j '#\u '#\l '#\y) '(jul))
          (('#\j '#\u '#\l) 'jul)
          (('#\a '#\u '#\g '#\u '#\s '#\t) '(aug))
          (('#\a '#\u '#\g) '(aug))
          (('#\s '#\e '#\p '#\t '#\e '#\m '#\b '#\e '#\r) '(sep))
          (('#\s '#\e '#\p) '(sep))
          (('#\o '#\c '#\t '#\o '#\b '#\e '#\r) '(oct))
          (('#\o '#\c '#\t) '(oct))
          (('#\n '#\o '#\v '#\e '#\m '#\b '#\e '#\r) '(nov))
          (('#\n '#\o '#\v) '(nov))
          (('#\d '#\e '#\c '#\e '#\m '#\b '#\e '#\r) '(dec))
          (('#\d '#\e '#\c) '(dec))
          (('#\u '#\t '#\c) '(utc))
          (('#\f '#\r '#\o '#\m) '(from))
          (('#\u '#\n '#\t '#\i '#\l) '(until))
          (('#\o '#\n) '(on))
          (('#\a '#\t) '(at))
          (('#\i '#\n) '(in))
          (('#\t '#\o) '(to))
          (('#\-) '(#\-))
          (('#\,) '(#\,)))
         (<date>
          ((d := <slash-date>) (cons 'locale-date d))
          ((d := <hyphen-date>) (cons 'iso-date d))
          ((d := <dotted-date>) (cons 'iso-date d)))
         (<slash-date>
          ((a := <1or2digit> '#\/ b := <1or2digit> '#\/ y := <2or4digit>)
           (list (cons 'year (cdr y)) (cons 'locale-first (cdr a)) (cons 'locale-second (cdr b))))
          ((a := <1or2digit> '#\/ b := <1or2digit>)
           (list (cons 'locale-first (cdr a)) (cons 'locale-second (cdr b)))))
         (<dotted-date>
          ((y := <2or4digit> '#\. m := <1or2digit> '#\. d := <1or2digit>)
           (list (cons 'year (cdr y)) (cons 'month (cdr m)) (cons 'day (cdr d)))))
         (<hyphen-date>
          ((y := <2or4digit> '#\- m := <1or2digit> '#\- d := <1or2digit>)
           (list (cons 'year (cdr y)) (cons 'month (cdr m)) (cons 'day (cdr d)))))
         (<hour-minute>
          ((h := <1or2digit> '#\: m := <2digit>) (list 'hour-minute (cdr h) (cdr m))))
         (<1or2digit>
          ((d := <1digit>) d)
          ((d := <2digit>) d))
         (<2or4digit>
          ((d := <2digit>) d)
          ((d := <4digit>) d))
         (<integer>
          ((d := <1digit>) d)
          ((d := <2digit>) d)
          ((d := <4digit>) d)
          ((d := <digit>+) (cons 'integer (string->number (list->string d)))))
         (<1digit>
          ((d := <digit> (! <digit>)) (cons '1digit (chars->num d))))
         (<2digit>
          ((d1 := <digit> d2 := <digit> (! <digit>)) (cons '2digit (chars->num d1 d2))))
         (<4digit>
          ((d1 := <digit> d2 := <digit> d3 := <digit> d4 := <digit> (! <digit>)) (cons '4digit (chars->num d1 d2 d3 d4))))
         (<digit>+
          ((d := <digit> d+ := <digit>+) (cons d d+))
          ((d := <digit> (! <digit>)) (list d)))
         (<digit>
          ((d := (? char-numeric?)) d))))

(define parser
  (parse <timespec>
         (<timespec>
          ((d := <duration-base>) d)
          ((s := <spec-base>) s)
          ((d := <delta-base>) d))
         (<duration-base>
          ((p := <prefixed-duration>) p)
          ((d := <duration>) d))
         (<prefixed-duration>
          (('from t := <duration>) t))
         (<duration>
          ((s := <spec-base> <duration-span> e := <spec-base>)
           (list (cons 'start s) (cons 'end e)))
          ((d := <date-time-duration>) d)
          ((d := <date-duration>) d)
          ((t := <time-duration>) t))
         (<date-time-duration>
          ((d := <date-spec> t := <time-duration>)
           (let ((start (cdr (assoc 'start t)))
                 (end (cdr (assoc 'end t))))
             (list (cons 'start (append d start))
                   (cons 'end (append d end)))))
          ((t := <time-duration> d := <date-spec>)
           (let ((start (cdr (assoc 'start t)))
                 (end (cdr (assoc 'end t))))
             (list (cons 'start (append d start))
                   (cons 'end (append d end))))))
         (<date-duration>
          ((n := <1or2digit> <duration-span> d := <date-spec>)
           (list (cons 'start
                       (map (lambda (i)
                              (if (eq? (car i) 'day) (cons 'day n) i)) d))
                 (cons 'end d))))
         (<time-duration>
          ((h := <1or2digit> <duration-span> e := <time-spec>)
           (list (list 'start
                       (cons 'hour (if (and (> (cdr (assoc 'hour e)) 12)
                                            (< (+ 12 h) (cdr (assoc 'hour e))))
                                       (+ 12 h) h))
                       (cons 'minute 0))
                 (cons 'end e))))
         (<1or2digit>
          ((d := '1digit) d)
          ((d := '2digit) d))
         
         (<duration-span>
          (('#\-) #t)
          (('to) #t)
          (('until) #t))
         (<spec-base>
          ((d := <date> t := <time>) (append d t))
          ((t := <time> d := <date>) (append d t))
          ((d := <date>) d)
          ((t := <time>) t))
         
         
         (<time>
          (('at t := <time-spec>) t)
          ((t := <time-spec>) t))
         (<time-spec>
          ((t := <time-base> z := <timezone>) (append t z))
          ((t := <time-base>) t))
         (<time-base>
          ((t := <time-hour-minute> 'am) (let ((hour (car t))
                                               (minute (cdr t)))
                                           (cond ((= hour 0) (error "hour too small"))
                                                 ((> hour 12) (error "hour too large"))
                                                 ((> minute 59) (error "minute too large"))
                                                 ((= hour 12) (list (cons 'hour 0)
                                                                    (cons 'minute minute)))
                                                 (else (list (cons 'hour hour)
                                                             (cons 'minute minute))))))
          ((t := <time-hour-minute> 'pm) (let ((hour (car t))
                                               (minute (cdr t)))
                                           (cond ((= hour 0) (error "hour too small"))
                                                 ((> hour 12) (error "hour too large"))
                                                 ((> minute 59) (error "minute too large"))
                                                 ((< hour 12) (list (cons 'hour (+ 12 hour))
                                                                    (cons 'minute minute)))
                                                 (else (list (cons 'hour hour)
                                                             (cons 'minute minute))))))
          ((t := <time-hour-minute>) (let ((hour (car t))
                                           (minute (cdr t)))
                                       (cond ((> hour 23) (error "hour too large"))
                                             ((> minute 59) (error "minute too large"))
                                             (else (list (cons 'hour hour)
                                                         (cons 'minute minute))))))
          ((h := <time-hour> 'am) (cond ((= h 0) (error "hour too small"))
                                        ((> h 12) (error "hour too large"))
                                        ((= h 12) (list (cons 'hour 0) (cons 'minute 0)))
                                        (else (list (cons 'hour h)))))
          ((h := <time-hour> 'pm) (cond ((= h 0) (error "hour too small"))
                                        ((> h 12) (error "hour too large"))
                                        ((< h 12) (list (cons 'hour (+ h 12))
                                                        (cons 'minute 0)))
                                        (else (list (cons 'hour h) (cons 'minute 0)))))
          ((t := 'noon) (list (cons 'hour 12)
                              (cons 'minute 0)))
          ((t := 'midday) (list (cons 'hour 12)
                                (cons 'minute 0)))
          ((t := 'midnight) (list (cons 'hour 0)
                                  (cons 'minute 0))))
         (<timezone>
          ((z := 'tz) (list (cons 'tz z))))
         (<time-hour>
          ((h := '1digit) h)
          ((h := '2digit) h))
         (<time-hour-minute>
          ((t := 'hour-minute) (cons (car t)
                                     (cadr t))))
         (<time-period>
          ((m := 'minute) 'minute)
          ((h := 'hour) 'hour))
         
         (<date>
          (('next p := <date-period>) (list 'delta
                                            (cons 'amount 1)
                                            (cons 'period p)))
          (('next d := <day-of-week>) d)
          (('next m := <month-name>) (list m))
          (('this d := <day-of-week>) d)
          (('this m := <month-name>) (list m))
          (('on d := <date-spec>) d)
          ((d := <date-spec>) d))
         (<date-spec>
          ((m := <month-name> d := <day-number> '#\, y := <year>) (list y m d))
          ((m := <month-name> d := <day-number> y := <year>) (list y m d))
          ((m := <month-name> d := <day-number>) (list m d))
          ((d := <day-number> m := <month-name> '#\, y := <year>) (list y m d))
          ((d := <day-number> m := <month-name> y := <year>) (list y m d))
          ((d := <day-number> m := <month-name>) (list m d))
          (('today) (current 'day 'month 'year))
          (('tomorrow) (let ((tomorrow (date+ (current-date) 1)))
                         (list (cons 'year (date-year tomorrow))
                               (cons 'month (date-month tomorrow))
                               (cons 'day (date-day tomorrow)))))
          ((d := 'locale-date) d)
          ((d := 'iso-date) d))
         (<month-name>
          (('jan) '(month . 1))
          (('feb) '(month . 2))
          (('mar) '(month . 3))
          (('apr) '(month . 4))
          (('may) '(month . 5))
          (('jun) '(month . 6))
          (('jul) '(month . 7))
          (('aug) '(month . 8))
          (('sep) '(month . 9))
          (('oct) '(month . 10))
          (('nov) '(month . 11))
          (('dec) '(month . 12)))
         (<day-number>
          ((d := '1digit) (cons 'day d))
          ((d := '2digit) (cons 'day d)))
         (<year>
          ((y := '2digit) (cons 'year (+ 2000 y)))
          ((y := '4digit) (cons 'year y)))
         (<day-of-week>
          (('sun) (day->date 0))
          (('mon) (day->date 1))
          (('tue) (day->date 2))
          (('wed) (day->date 3))
          (('thu) (day->date 4))
          (('fri) (day->date 5))
          (('sat) (day->date 6)))
         (<date-period>
          (('day) 'day)
          (('week) 'week)
          (('month) 'month)
          (('year) 'year))
         (<delta-base>
          (('in t := <time-delta>) t)
          (('in d := <date-delta>) d))
         (<time-delta>
          ((n := <number> p := <time-period>) (list 'delta n p)))
         (<date-delta>
          ((n := <number> p := <date-period>) (list 'delta n p)))
         (<number>
          ((n := '1digit) n)
          ((n := '2digit) n)
          ((n := 'integer) n))))

(define (par l)
  (let ((r (parser (packrat-list-results l))))
    (if (parse-result-successful? r)          
        (parse-result-semantic-value r)
        (parse-result-error r))))
(define (lex s)
  (let loop ((rs (packrat-string-results "fn" s)))
    (let ((r (lexer rs)))
      (if (parse-result-successful? r)          
          (cons (parse-result-semantic-value r)
                (loop (parse-result-next r)))
          empty))))

(define (lex-list l)
  (let loop ((rs (packrat-list-results l)))
    (let ((r (lexer rs)))
      (if (parse-result-successful? r)          
          (cons (parse-result-semantic-value r)
                (loop (parse-result-next r)))
          empty))))

(define (parse-list l)
  (if (null? l) empty
      (let ((r (par (lex-list l))))
        (if (parse-error? r)
            (cons (caar l)
                  (parse-list (cdr l)))
            r))))

(define (string->lex-list str)
  (map (lambda (c) (cons c c)) (string->list str)))

(define (parse-string str)
  (parse-list (string->lex-list str)))


; Time tests
(check-expect (parse-string "10:00") '((hour . 10) (minute . 0)))
(check-expect (parse-string "00:00") '((hour . 0) (minute . 0)))
(check-expect (parse-string "13:59") '((hour . 13) (minute . 59)))
(check-expect (parse-string "2:50") '((hour . 2) (minute . 50)))
(check-expect (parse-string "0:10") '((hour . 0) (minute . 10)))
(check-expect (parse-string "2:50am") '((hour . 2) (minute . 50)))
(check-expect (parse-string "2:50pm") '((hour . 14) (minute . 50)))
(check-expect (parse-string "12:45pm") '((hour . 12) (minute . 45)))
(check-expect (parse-string "1:45pm") '((hour . 13) (minute . 45)))
(check-expect (parse-string "1:45pm aedt") '((hour . 13) (minute . 45) (tz AEDT +1100)))
(check-expect (parse-string "12am") '((hour . 0) (minute . 0)))
(check-expect (parse-string "12pm") '((hour . 12) (minute . 0)))
(check-expect (parse-string "1pm") '((hour . 13) (minute . 0)))
(check-error (parse-string "2:60") "minute too large")
(check-error (parse-string "25:20") "hour too large")
(check-error (parse-string "13:01pm") "hour too large")
(check-error (parse-string "13:01am") "hour too large")
(check-error (parse-string "2:60am") "minute too large")
(check-error (parse-string "2:60pm") "minute too large")
(check-error (parse-string "0:23am") "hour too small")
(check-error (parse-string "0:30pm") "hour too small")
(check-expect (parse-string "noon") '((hour . 12) (minute . 0)))
(check-expect (parse-string "midday") '((hour . 12) (minute . 0)))
(check-expect (parse-string "midnight") '((hour . 0) (minute . 0)))

; Date tests
(check-expect (parse-string "april 20, 2012") '((year . 2012) (month . 4) (day . 20)))
(check-expect (parse-string "april 21 2012") '((year . 2012) (month . 4) (day . 21)))
(check-expect (parse-string "22 april 2012") '((year . 2012) (month . 4) (day . 22)))
(check-expect (parse-string "23 april, 2012") '((year . 2012) (month . 4) (day . 23)))
(check-expect (parse-string "24 april") '((month . 4) (day . 24)))
(check-expect (parse-string "april 25") '((month . 4) (day . 25)))
(check-expect (parse-string "jan 1") '((month . 1) (day . 1)))
(check-expect (parse-string "26/10/2012") '((year . 2012) (locale-first . 26) (locale-second . 10)))
(check-expect (parse-string "26/10") '((locale-first . 26) (locale-second . 10)))
(check-expect (parse-string "2012-10-26") '((year . 2012) (month . 10) (day . 26)))
(check-expect (parse-string "next april") '((month . 4)))
(check-expect (parse-string "this january") '((month . 1)))
#;(check-expect (parse-string "next tuesday") '((month . 4)))

; Duration tests
(check-expect (parse-string "from 12:30pm to 1:30pm")
              '((start (hour . 12) (minute . 30))
                (end (hour . 13) (minute . 30))))
(check-expect (parse-string "from 12:30pm until 1:30pm")
              '((start (hour . 12) (minute . 30))
                (end (hour . 13) (minute . 30))))
(check-expect (parse-string "12:30pm-1:30pm")
              '((start (hour . 12) (minute . 30))
                (end (hour . 13) (minute . 30))))
(check-expect (parse-string "from 12am-1pm")
              '((start (hour . 0) (minute . 0))
                (end (hour . 13) (minute . 0))))
(check-expect (parse-string "12 oct 2012 1pm to 2pm 2012-10-13")
              '((start (year . 2012) (month . 10) (day . 12)
                       (hour . 13) (minute . 0))
                (end  (year . 2012) (month . 10) (day . 13)
                      (hour . 14) (minute . 0))))
(check-expect (parse-string "7pm-8pm")
              '((start (hour . 19) (minute . 0))
                (end (hour . 20) (minute . 0))))
(check-expect (parse-string "9-8pm")
              '((start (hour . 9) (minute . 0))
                (end (hour . 20) (minute . 0))))
(check-expect (parse-string "11-1pm")
              '((start (hour . 11) (minute . 0))
                (end (hour . 13) (minute . 0))))
(check-expect (parse-string "12-14 october")
              '((start (month . 10) (day . 12))
                (end (month . 10) (day . 14))))
(check-expect (parse-string "from 2012.2.12 until 26/10/2012")
              '((start (year . 2012) (month . 2) (day . 12))
                (end (year . 2012) (locale-first . 26) (locale-second . 10))))
(check-expect (parse-string "6/12 7-8pm")
              '((start (locale-first . 6) (locale-second . 12) (hour . 19) (minute . 0))
                (end (locale-first . 6) (locale-second . 12) (hour . 20) (minute . 0))))
(test)